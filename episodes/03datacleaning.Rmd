---
title: 'Data cleaning using R'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- What is DE analysis

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- To do DE analysis

::::::::::::::::::::::::::::::::::::::::::::::::

## Load processed data and sample annotation 

After processing raw proteomics data, further cleaning and analysis can be conducted using R, Python, or by importing data to other platforms like **Perseus** or **Skyline**.

In this workshop, we will be teaching you one method of cleaning and analysing proteomics data using R. To follow along the remainder of this workshop, you should **open a new R script in RStudio** and **run the example code provided.**

:::callout

# The limpa package

In this workshop, we are using the *limpa* package to load and clean our data. This package was published in 2025 by the [Smyth Lab](https://github.com/SmythLab/limpa), based at the Walter and Eliza Hall Institute of Medical Research (WEHI). 

For background information, see the original publications:

Li M, Cobbold SA, Smyth GK (2025). “Quantification and differential analysis of mass spectrometry proteomics data with probabilistic recovery of information from missing values.” bioRxiv, April 29, 651125. doi:10.1101/2025.04.28.651125.

Li M, Smyth GK (2023). “Neither random nor censored: estimating intensity-dependent probabilities for missing values in label-free proteomics.” Bioinformatics, 39(5), btad200. doi:10.1093/bioinformatics/btad200.

You can also find further information in the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/limpa/inst/doc/limpa.html) or [reference manual](https://bioconductor.org/packages/release/bioc/manuals/limpa/man/limpa.pdf) accessed via the [Bioconductor page](https://bioconductor.org/packages/release/bioc/html/limpa.html).

:::

First, load the required R packages.

```{r, eval=FALSE}
library(limpa)
library(readxl)
library(pheatmap)
library(EnhancedVolcano)
library(STRINGdb)
library(clusterProfiler)
library(org.Hs.eg.db)
library(arrow)
library(rpx)
library(dplyr)
```

Load the peptide-level data processed by DIA-NN (`.parquet` file), filtering observations by quality metrics as recommended in the [limpa vignette](https://bioconductor.org/packages/release/bioc/vignettes/limpa/inst/doc/limpa.html).

```{r}
y.peptide <- readDIANN(file='data/MBIntroToProteomics.parquet',format="parquet",
                       q.columns = c("Q.Value","Lib.Q.Value","Lib.PG.Q.Value"),
                       q.cutoffs = 0.01)
```

:::challenge

These quality filtering metrics are recommended in the [limpa vignette](https://bioconductor.org/packages/release/bioc/vignettes/limpa/inst/doc/limpa.html) for data searched in DIA-NN **with match-between-runs**.

What q.columns are recommended for data searched **without MBR**?

:::solution

```{r}
y.peptide <- readDIANN(file='data/MBIntroToProteomics.parquet',format="parquet",
                       q.columns = c("Q.Value","Global.Q.Value","Global.PG.Q.Value"),
                       q.cutoffs = 0.01)
```

:::

Let's look at the structure of the data.

```{r}
names(y.peptide)

head(y.peptide$E)
head(y.peptide$genes)
```

As you can see, 'E' is our peptide matrix and 'genes' is a dataframe containing information about each peptide.

We also need to import information about our samples for later analyses.

```{r}
samples_stool <- as.data.frame(readxl::read_excel('data/SampleAnnotation.xlsx'))
head(samples_stool)
```

We need to clean our sample annotation data to add an identifying column which matches the sample column names in our peptide data.

Given we are only using a subset of the main dataset in this workshop, we can also filter the sample annotation dataframe to only include rows pertaining to the samples in our subset.

```{r}
# Create sample_name column
samples_stool$fixed_file_name <- gsub("\\\\", "/", samples_stool$file_name)
samples_stool$fixed_file_name <- basename(samples_stool$fixed_file_name)
samples_stool$sample_name <- gsub(".mzML", "",samples_stool$fixed_file_name)

# Filter to only samples present in our dataset
samples_stool <- samples_stool %>% filter(samples_stool$sample_name %in% colnames(y.peptide$E))
```

## Quality filtering

After reading in the data, it is common to conduct additional filtering to improve the quality of your data and assist with downstream interpretation of results.

- **Filtering out non-proteotypic peptides:** Removes peptides that belong to more than one protein.
- **Filtering out compound proteins:** Removes peptides belonging to compound protein groups consisting of multiple proteins separated by ";" delimiters.
- **Filtering out singleton peptides:** Removes peptides that are the only peptide belonging to that protein (i.e. keeps only proteins with multiple peptides).

```{r}
y.peptide <- filterNonProteotypicPeptides(y.peptide)
y.peptide <- filterCompoundProteins(y.peptide)
y.peptide <- filterSingletonPeptides(y.peptide, min.n.peptides = 2)
```

These filtering steps are optional; limpa will still work if they are not run. For more information about these peptide-level filters and whether they are appropriate for your experiment, please consult the limpa documentation.

## Removing contaminants




The contaminant information is on GitHub and can be downloaded from their GitHub page.

More info available here: 
Frankenfield AM, Ni J, Ahmed M, Hao L. Protein contaminants matter: building universal protein contaminant libraries for DDA and DIA proteomics. Journal of proteome research. 2022 Jul 6;21(9):2104-13. https://pubs.acs.org/doi/full/10.1021/acs.jproteome.2c00145



```{r, eval=FALSE}

# Code for downloading the contaminant libraries

# curl::curl_download('https://github.com/HaoGroup-ProtContLib/Protein-Contaminant-Libraries-for-DDA-and-DIA-Proteomics/raw/refs/heads/main/Universal%20protein%20contaminant%20FASTA/Contaminant%20protein%20information%20in%20the%20FASTA%20library%20and%20the%20potential%20source%20of%20contaminations.xlsx',destfile = 'data/Contaminants.xlsx')

```




```{r}


contaminants <- as.data.frame(readxl::read_excel('data/Contaminants.xlsx'))
contaminants_colnames <- as.character(contaminants[1,])
contaminants <- contaminants[2:nrow(contaminants),]
colnames(contaminants) <- contaminants_colnames

```

```{r}

# Check how many proteins match contaminants
table(y.peptide$genes$Protein.Group %in% contaminants$`Uniprot ID`)

# Filter out contaminants
y.peptide$genes <- dplyr::filter(y.peptide$genes, !(Protein.Group %in% contaminants$`Uniprot ID`))
y.peptide$E <- y.peptide$E[rownames(y.peptide$genes), ]

# Confirm removal
table(y.peptide$genes$Protein.Group %in% contaminants$`Uniprot ID`)

```


### Align sample metadata


```{r}


sample_info <- samples_stool[samples_stool$sample_name %in% colnames(y.peptide$E),]
rownames(sample_info) <- sample_info$sample_name
y.peptide$E <- y.peptide$E[,rownames(sample_info)]

# Add experimental metadata
y.peptide$targets <- sample_info[, c('Class', 'Batch')]

```



### Dimensionality Reduction and QC

```{r}

dpcfit <- dpc(y.peptide)
plotDPC(dpcfit)

```


By protein:

```{r}

y.protein <- dpcQuant(y.peptide, "Protein.Names", dpc=dpcfit)
plotMDSUsingSEs(y.protein)

```

That plot is extremely messy and doesn't tell us much! Let's clean it up.


```{r}

# Class visualisation
Class <- factor(y.peptide$targets$Class)
levels(Class) <- c("Ctrl","aCD","aUC","CDr","UCr")
Class.color <- Class
levels(Class.color) <- c("pink","black",'grey','darkorange','darkgreen')
plotMDSUsingSEs(y.protein, pch=16, col=as.character(Class.color))

```

Hmmm, not a lot of differences. Let's see if there are any batch effects.

```{r}

# Batch visualisation
Batch <- factor(y.peptide$targets$Batch)
Batch.color <- Batch
levels(Batch.color) <- c("green","purple",'orange')
plotMDSUsingSEs(y.protein, pch=16, col=as.character(Batch.color))

```

It looks like there are some differences between the batches. Let's remove the batch effects and see how it looks.


```{r}

# Correct for batch effects
y.protein.rbe <- removeBatchEffect(y.protein,batch = y.protein$targets$Batch)
plotMDS(y.protein.rbe, pch=16, col=as.character(Batch.color))

```

## Subset Comparison: Ctrl vs aUC

```{r}

cdr_bool <- y.peptide$targets$Class %in% c('Ctrl','aUC')

plotMDSUsingSEs(y.protein[, cdr_bool], 
                pch=16, col=as.character(Class.color[cdr_bool]))

plotMDS(y.protein[, cdr_bool], 
         pch=16, col=as.character(Class.color[cdr_bool]))

plotMDS(y.protein.rbe[, cdr_bool], 
         pch=16, col=as.character(Class.color[cdr_bool]))


```

We should add batch as a covariate to our analysis.

## Differential Expression Analysis

We now fit a linear model that includes both Class and Batch effects.

```{r}

design <- model.matrix(~0 + Class + Batch)
fit <- dpcDE(y.protein, design, plot = TRUE)
fit <- eBayes(fit)



```

```{r}

topTable(fit, coef = "ClassCtrl")


```

## Create and Explore Contrasts

We can define custom contrasts (e.g., comparing aCD vs Ctrl) and explore differential proteins.

```{r}

# Define contrasts
contrasts_fit <- makeContrasts(Ctrl_aCD = ClassaCD - ClassCtrl, 
                               levels = colnames(design))

# Apply contrasts
fit2 <- contrasts.fit(fit, contrasts = contrasts_fit)
fit2 <- eBayes(fit2)

# Summaries
topTable(fit2, coef = 1)

```

```{r}

# Compare multiple coefficients
topTable(fit, coef = 1)
topTable(fit, coef = 3)
topTable(fit, coef = 4)
topTable(fit, coef = 6)

# Example diagnostic plots
plotMD(fit, coef = 1)
plotMD(fit, coef = 2)

```

## Example: aUC vs Ctrl Comparison

```{r}

results <- topTable(fit, coef = 3, number = Inf)

# Visualize a specific protein
plotProtein(y.protein, "S10A9_HUMAN", col = as.character(Class.color))
legend('topleft', legend = levels(Class), fill = levels(Class.color))

```

## Visualize Top Significant Proteins

We identify the top 50 most significant and variable proteins, then visualize via a clustered heatmap.

```{r}

sig_proteins <- results %>%
  filter(adj.P.Val < 0.05) %>%
  top_n(50, wt = abs(logFC)) %>%
  pull(Protein.Names)

expr_matrix <- y.protein$E[sig_proteins, ]
scaled_expr <- t(scale(t(expr_matrix)))

col_annotation <- data.frame(Class = Class,
                             row.names = colnames(y.protein$E))

pheatmap(scaled_expr,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = col_annotation)

```


## Volcano plot

```{r}


EnhancedVolcano(results,
                lab = results$Protein.Names,
                x = 'logFC',
                y = 'adj.P.Val',
                pCutoff = 0.05,
                FCcutoff = 1.0,
                pointSize = 3.0,
                labSize = 3.0)


```


## Network and Enrichment Analysis

### STRING Protein–Protein Interaction Network

Note: this part does not seem to be working

```{r, eval=FALSE}

string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 400)
mapped <- string_db$map(results, "Protein.Names", removeUnmappedRows = TRUE)
de_proteins <- mapped %>% filter(adj.P.Val < 0.05)

# Plot network of significant proteins
string_db$plot_network(de_proteins$STRING_id)

```

### Functional Enrichment (GO and KEGG)

```{r}

de_proteins <- results %>% filter(adj.P.Val < 0.05)

# Convert UniProt IDs to Entrez IDs for enrichment
converted <- bitr(de_proteins$Protein.Group,
                  fromType = "UNIPROT",
                  toType = "ENTREZID",
                  OrgDb = org.Hs.eg.db)

# GO Biological Process enrichment
ego <- enrichGO(gene = converted$ENTREZID,
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                readable = TRUE)

dotplot(ego, showCategory = 10)

# KEGG pathway enrichment
ekegg <- enrichKEGG(gene = converted$ENTREZID,
                    organism = 'hsa',
                    pvalueCutoff = 0.05)

dotplot(ekegg, showCategory = 10)


```


## Potential next steps

* Compare coefficients between classes as an exercise.

* Visualize selected proteins of interest across experimental groups.

* Extend enrichment analyses using Reactome or GSEA approaches.

* Integrate sample metadata for clinical covariates or longitudinal modeling.




::::::::::::::::::::::::::::::::::::: keypoints 

- Data!

::::::::::::::::::::::::::::::::::::::::::::::::


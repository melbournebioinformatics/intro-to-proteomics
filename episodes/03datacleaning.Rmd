---
title: 'Data cleaning and DE analysis'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- What is DE analysis

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- To do DE analysis

::::::::::::::::::::::::::::::::::::::::::::::::



## Load processed data and additional files





```{r, echo=FALSE, message=FALSE,warning=FALSE}

library(limpa)
library(dplyr)
library(readxl)
library(pheatmap)
library(EnhancedVolcano)
library(STRINGdb)
library(clusterProfiler)
library(org.Hs.eg.db)
library(arrow)

```



```{r}

# Load peptide-level data processed by DIA-NN
y.peptide <- readDIANN(file='data/report_subset.parquet',format="parquet")

names(y.peptide)
```

## Annotating and filtering our dataset

In order to do differential expression analysis, we need information about what samples were used.


```{r}


# If you are on a Mac, this data needed to be cleaned up a bit with gsub if you download directly from PRIDE
samples_stool <- as.data.frame(readxl::read_excel('data/SampleAnnotation.xlsx'))
samples_stool$fixed_file_name <- gsub("\\\\", "/", samples_stool$file_name)
samples_stool$fixed_file_name <- basename(samples_stool$fixed_file_name)
samples_stool$sample_name <- gsub(".mzML", "",samples_stool$fixed_file_name)


```





The contaminant information is on GitHub and can be downloaded from their GitHub page.

More info available here: 
Frankenfield AM, Ni J, Ahmed M, Hao L. Protein contaminants matter: building universal protein contaminant libraries for DDA and DIA proteomics. Journal of proteome research. 2022 Jul 6;21(9):2104-13. https://pubs.acs.org/doi/full/10.1021/acs.jproteome.2c00145



```{r, eval=FALSE}

# Code for downloading the contaminant libraries

# curl::curl_download('https://github.com/HaoGroup-ProtContLib/Protein-Contaminant-Libraries-for-DDA-and-DIA-Proteomics/raw/refs/heads/main/Universal%20protein%20contaminant%20FASTA/Contaminant%20protein%20information%20in%20the%20FASTA%20library%20and%20the%20potential%20source%20of%20contaminations.xlsx',destfile = 'data/Contaminants.xlsx')

```




```{r}


contaminants <- as.data.frame(readxl::read_excel('data/Contaminants.xlsx'))
contaminants_colnames <- as.character(contaminants[1,])
contaminants <- contaminants[2:nrow(contaminants),]
colnames(contaminants) <- contaminants_colnames

```

```{r}

# Check how many proteins match contaminants
table(y.peptide$genes$Protein.Group %in% contaminants$`Uniprot ID`)

# Filter out contaminants
y.peptide$genes <- dplyr::filter(y.peptide$genes, !(Protein.Group %in% contaminants$`Uniprot ID`))
y.peptide$E <- y.peptide$E[rownames(y.peptide$genes), ]

# Confirm removal
table(y.peptide$genes$Protein.Group %in% contaminants$`Uniprot ID`)

```


### Align sample metadata


```{r}


sample_info <- samples_stool[samples_stool$sample_name %in% colnames(y.peptide$E),]
rownames(sample_info) <- sample_info$sample_name
y.peptide$E <- y.peptide$E[,rownames(sample_info)]

```



```{r}
# Add experimental metadata
y.peptide$targets <- sample_info[, c('Class', 'Batch')]

# Apply peptide-level filters
y.peptide <- filterNonProteotypicPeptides(y.peptide)
y.peptide <- filterCompoundProteins(y.peptide)
y.peptide <- filterSingletonPeptides(y.peptide, min.n.peptides = 2)


```


For more information on the peptide-level filters, please consult the limpa vignette.


### Dimensionality Reduction and QC

```{r}

dpcfit <- dpc(y.peptide)
plotDPC(dpcfit)

```


By protein:

```{r}

y.protein <- dpcQuant(y.peptide, "Protein.Names", dpc=dpcfit)
plotMDSUsingSEs(y.protein)

```

That plot is extremely messy and doesn't tell us much! Let's clean it up.


```{r}

# Class visualisation
Class <- factor(y.peptide$targets$Class)
levels(Class) <- c("Ctrl","aCD","aUC","CDr","UCr")
Class.color <- Class
levels(Class.color) <- c("pink","black",'grey','darkorange','darkgreen')
plotMDSUsingSEs(y.protein, pch=16, col=as.character(Class.color))

```

Hmmm, not a lot of differences. Let's see if there are any batch effects.

```{r}

# Batch visualisation
Batch <- factor(y.peptide$targets$Batch)
Batch.color <- Batch
levels(Batch.color) <- c("green","purple",'orange')
plotMDSUsingSEs(y.protein, pch=16, col=as.character(Batch.color))

```

It looks like there are some differences between the batches. Let's remove the batch effects and see how it looks.


```{r}

# Correct for batch effects
y.protein.rbe <- removeBatchEffect(y.protein,batch = y.protein$targets$Batch)
plotMDS(y.protein.rbe, pch=16, col=as.character(Batch.color))

```

## Subset Comparison: Ctrl vs aUC

```{r}

cdr_bool <- y.peptide$targets$Class %in% c('Ctrl','aUC')

plotMDSUsingSEs(y.protein[, cdr_bool], 
                pch=16, col=as.character(Class.color[cdr_bool]))

plotMDS(y.protein[, cdr_bool], 
         pch=16, col=as.character(Class.color[cdr_bool]))

plotMDS(y.protein.rbe[, cdr_bool], 
         pch=16, col=as.character(Class.color[cdr_bool]))


```

We should add batch as a covariate to our analysis.

## Differential Expression Analysis

We now fit a linear model that includes both Class and Batch effects.

```{r}

design <- model.matrix(~0 + Class + Batch)
fit <- dpcDE(y.protein, design, plot = TRUE)
fit <- eBayes(fit)



```

```{r}

topTable(fit, coef = "ClassCtrl")


```

## Create and Explore Contrasts

We can define custom contrasts (e.g., comparing aCD vs Ctrl) and explore differential proteins.

```{r}

# Define contrasts
contrasts_fit <- makeContrasts(Ctrl_aCD = ClassaCD - ClassCtrl, 
                               levels = colnames(design))

# Apply contrasts
fit2 <- contrasts.fit(fit, contrasts = contrasts_fit)
fit2 <- eBayes(fit2)

# Summaries
topTable(fit2, coef = 1)

```

```{r}

# Compare multiple coefficients
topTable(fit, coef = 1)
topTable(fit, coef = 3)
topTable(fit, coef = 4)
topTable(fit, coef = 6)

# Example diagnostic plots
plotMD(fit, coef = 1)
plotMD(fit, coef = 2)

```

## Example: aUC vs Ctrl Comparison

```{r}

results <- topTable(fit, coef = 3, number = Inf)

# Visualize a specific protein
plotProtein(y.protein, "S10A9_HUMAN", col = as.character(Class.color))
legend('topleft', legend = levels(Class), fill = levels(Class.color))

```

## Visualize Top Significant Proteins

We identify the top 50 most significant and variable proteins, then visualize via a clustered heatmap.

```{r}

sig_proteins <- results %>%
  filter(adj.P.Val < 0.05) %>%
  top_n(50, wt = abs(logFC)) %>%
  pull(Protein.Names)

expr_matrix <- y.protein$E[sig_proteins, ]
scaled_expr <- t(scale(t(expr_matrix)))

col_annotation <- data.frame(Class = Class,
                             row.names = colnames(y.protein$E))

pheatmap(scaled_expr,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = TRUE,
         show_colnames = FALSE,
         annotation_col = col_annotation)

```


## Volcano plot

```{r}


EnhancedVolcano(results,
                lab = results$Protein.Names,
                x = 'logFC',
                y = 'adj.P.Val',
                pCutoff = 0.05,
                FCcutoff = 1.0,
                pointSize = 3.0,
                labSize = 3.0)


```


## Network and Enrichment Analysis

### STRING Proteinâ€“Protein Interaction Network

Note: this part does not seem to be working

```{r, eval=FALSE}

string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 400)
mapped <- string_db$map(results, "Protein.Names", removeUnmappedRows = TRUE)
de_proteins <- mapped %>% filter(adj.P.Val < 0.05)

# Plot network of significant proteins
string_db$plot_network(de_proteins$STRING_id)

```

### Functional Enrichment (GO and KEGG)

```{r}

de_proteins <- results %>% filter(adj.P.Val < 0.05)

# Convert UniProt IDs to Entrez IDs for enrichment
converted <- bitr(de_proteins$Protein.Group,
                  fromType = "UNIPROT",
                  toType = "ENTREZID",
                  OrgDb = org.Hs.eg.db)

# GO Biological Process enrichment
ego <- enrichGO(gene = converted$ENTREZID,
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                readable = TRUE)

dotplot(ego, showCategory = 10)

# KEGG pathway enrichment
ekegg <- enrichKEGG(gene = converted$ENTREZID,
                    organism = 'hsa',
                    pvalueCutoff = 0.05)

dotplot(ekegg, showCategory = 10)


```


## Potential next steps

* Compare coefficients between classes as an exercise.

* Visualize selected proteins of interest across experimental groups.

* Extend enrichment analyses using Reactome or GSEA approaches.

* Integrate sample metadata for clinical covariates or longitudinal modeling.




::::::::::::::::::::::::::::::::::::: keypoints 

- Data!

::::::::::::::::::::::::::::::::::::::::::::::::

